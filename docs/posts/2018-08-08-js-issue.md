
js的一些问题总结:
## new操作符
四步:
1. 创空对象`var obj=new object()` 
2. 设置原型链`obj._proto_ = fn.prototype` 
3. fn的this 指向obj ,执行fn函数体`var result = fn.call(obj)` 
4. 判断fn的返回值类型，如果是值类型，返回obj。如果是引用类型，就返回这个引用类型的对象。
```javascript
if (typeof(result) == "object"){ 
fnObj = result; 
} else { 
fnObj = obj;} 
```
## js对象
Object 是 JavaScript 中所有对象的父对象   
数据封装类对象：Object、Array、Boolean、Number 和 String     
其他对象：Function、Arguments、Math、Date、RegEx、Error

## width
1. offsetWidth/offsetHeight返回值包含content + padding + border，效果与e.getBoundingClientRect()相同 
2. clientWidth/clientHeight返回值只包含content + padding，如果有滚动条，也不包含滚动条 
3. scrollWidth/scrollHeight返回值包含content + padding + 溢出内容的尺寸

## mouseover/out
- mouseover/mouseout是标准事件，所有浏览器都支持；mouseenter/mouseleave是IE5.5引入的特有事件后来被DOM3标准采纳，现代标准浏览器也支持 
- mouseover/mouseout是冒泡事件；mouseenter/mouseleave不冒泡。需要为多个元素监听鼠标移入/出事件时，推荐mouseover/mouseout托管，提高性能 
- 标准事件模型中event.target表示发生移入/出的元素,vent.relatedTarget对应移出/如元素；在老IE中event.srcElement表示发生移入/出的元素，event.toElement表示移出的目标元素，event.fromElement表示移入时的来源元素

## 函数节流
 函数节流(throttle)是指阻止一个函数在很短时间间隔内连续调用。 只有当上一次函数执行后达到规定的时间间隔，才能进行下一次调用。 但要保证一个累计最小调用间隔  
 应用场景:
1. DOM 元素的拖拽功能实现（mousemove）
2. 射击游戏的 mousedown/keydown 事件（单位时间只能发射一颗子弹）
3. 计算鼠标移动的距离（mousemove）
4. Canvas 模拟画板功能（mousemove
5. 搜索联想（keyup
6. 监听滚动事件判断是否到页面底部自动加载更多：给 scroll 加了 debounce 后，只有用户停止滚动后，才会判断是否到了页面底部；如果是 throttle 的话，只要页面滚动就会间隔一段时间判断一次

 #### 简单实现:
```javascript
 //定时器
 function throttle(method, context) { 
    clearTimeout(methor.tId); 
    method.tId = setTimeout(function(){ 
        method.call(context); 
    }， 100); // 两次调用至少间隔 100ms 
} 
//另一种
function throttlePro(delay, action) {
    let tId;
    return function () {
        let context = this;
        let arg = arguments;
        if (tId) return;
        tId = setTimeout(function () {
            action.apply(context, arg);
            clearTimeout(tId);
            // setTimeout 返回一个整数，clearTimeout 之后，tId还是那个整数,setInterval同样如此
            tId = null;
        }, delay);
    }
}
// 调用 
window.onresize = function(){ 
   throttle(myFunc, window); 
} 
//时间戳
function throttle(delay, action) {
    let last = 0;
    return function() {
        let curr = new Date();
        if (curr - last > delay) {
            action.apply(this, arguments);
            last = curr;
        }
    }
}
```
## 函数去抖
去抖 (debounce) 去抖就是对于一定时间段的连续的函数调用，只让其执行一次
思路:创建一个定时器，在指定的时间间隔之后运行代码。当第二次调用该函数时，清除前一次的定时器并设置另一个。如果前一个定时器已经执行过了，这个操作就没有任何意义。然而，如果前一个定时器尚未执行，其实就是将其替换为一个新的定时器。目的是只有在执行函数的请求停止了一段时间之后才执行。
应用场景:
1. 每次 resize/scroll 触发统计事件
2. 文本输入的验证（连续输入文字后发送 AJAX 请求进行验证，验证一次就好） 

实现:

```javascript
const debounce = (fn, wait = 500) => {
  return function () {
    clearTimeout(fn.timer)
    fn.timer = setTimeout(fn.bind(this, ...arguments), wait)
  }
}
//another
function debounce(method, context) {
  clearTimeout(method.tId);
  method.tId = setTimeout(function() {
    method.call(context);
  }, 1000);
}

function print() {
  console.log('hello world');
}

window.onscroll = function() {//使用
  debounce(print);
};
```
改动:
```javascript
function debounce(delay, action) {
    let tId;
    return function () {
        let context = this;
        let arg = arguments;
        if (tId) clearTimeout(tId);
        tId = setTimeout(function () {
            action.apply(context, arg);
        }, delay);
    }
}

window.onscroll = debounce(1000, print);
```

## DOM
1. DOM0事件
    btn.onclick=func;
2. DOM2事件
```javascript
btn.addEventListener('click', func, false); 
btn.removeEventListener('click', func, false); 
btn.attachEvent("onclick", func); 
btn.detachEvent("onclick", func); 
```
3. DOM3事件
```javascript
eventUtil.addListener(input, "textInput", func); 
// eventUtil 是自定义对象，textInput 是DOM3级事件
```
## 字符串转数字

```js
parseInt(num); // 默认方式 (没有基数)
parseInt(num, 10); // 传入基数 (十位数)
parseFloat(num) // 浮点数
Number(num); // Number 构造器
~~num //按位非
num / 1 // 除一个数
num * 1 // 乘一个数
num - 0 // 减去0
+num // 一元运算符 "+"
```

## 千分位  

```js
function numberWithCommas(x = 0) {
  return x.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',')
}
//最简单的
const num=1244545334
num.toLocaleString() // "1,244,545,334"
```

## array方法总结
`for while for of` 可以break, 退出循环 `forEach map` 无法跳出
[详细](https://juejin.im/post/5b684ef9e51d451964629ba1)
![array]({../img/array.png 'array')