## JS questions

1. 
```js
function bark() {
  console.log("Woof!");
}

bark.animal = "dog";
//Nothing, this is totally fine!
//这在JavaScript中是可能的，因为函数也是对象！（原始类型之外的所有东西都是对象）
```
2. 
```js
function Person(firstName, lastName) {
  this.firstName = firstName;
  this.lastName = lastName;
}

const sarah = Person("Sarah", "Smith");

console.log(sarah);
//ans :undefined
// 不添加new它指的是全局对象,sarah本身的返回值是undefined
```
3. 事件传播的三个阶段

捕获 > 目标 > 冒泡,在捕获阶段，事件通过父元素向下传递到目标元素。 然后它到达目标元素，冒泡开始  

4. 除基础对象外，所有对象都有原型,基础对象指原型链终点的对象。基础对象的原型是`null`

5. 
```js
function getPersonInfo(one, two, three) {
  console.log(one);
  console.log(two);
  console.log(three);
}

const person = "Lydia";
const age = 21;

getPersonInfo`${person} is ${age} years old`;
// ["", "is", "years old"] Lydia 21
//第一个参数的值始终是字符串值的数组。 其余参数获取传递到模板字符串中的表达式的值！
```
6. 
```js
function checkAge(data) {
  if (data === { age: 18 }) {
    console.log("You are an adult!");
  } else if (data == { age: 18 }) {
    console.log("You are still an adult.");
  } else {
    console.log(`Hmm.. You don't have an age I guess`);
  }
}

checkAge({ age: 18 });
//Hmm.. You don't have an age I guess
//比较相等性，原始类型通过它们的值进行比较，而对象通过它们的引用进行比较。
//JavaScript检查对象是否具有对内存中相同位置的引用。
```
7. 
```js
const obj = { 1: "a", 2: "b", 3: "c" };
const set = new Set([1, 2, 3, 4, 5]);

obj.hasOwnProperty("1");
obj.hasOwnProperty(1);
set.has("1");
set.has(1);
//true true false true
// 所有对象键（不包括Symbols）都会被存储为字符串，即使你没有给定字符串类型的键
```
8. 
```js
const obj = { a: "one", b: "two", a: "three" };
console.log(obj);
//{ a: "three", b: "two" }
//对象有两个具有相同名称的键，则将替前面的键。它仍将处于第一个位置，但具有最后指定的值。
```
9. 
```js
const a = {};
const b = { key: "b" };
const c = { key: "c" };

a[b] = 123;
a[c] = 456;

console.log(a[b]);
//456
//当对象自动转换为字符串化时，它变成了[Object object]
//我们打印a[b]，它实际上是a["Object object"]
```
10. 
```js
<div onclick="console.log('first div')">
  <div onclick="console.log('second div')">
    <button onclick="console.log('button')">
      Click!
    </button>
  </div>
</div>
//点击button event.target==> button
// 导致事件的最深嵌套元素是事件的目标
```
11. 

```js
<div onclick="console.log('div')">
  <p onclick="console.log('p')">
    Click here!
  </p>
</div>
//p  div
//在事件传播期间，有三个阶段：捕获，目标和冒泡。 默认情况下，
// 事件处理程序在冒泡阶段执行（除非您将useCapture设置为true）。 它从最深的嵌套元素向外延伸。
```
12. 
```js
const person = { name: "Lydia" };

function sayHi(age) {
  console.log(`${this.name} is ${age}`);
}

sayHi.call(person, 21);
sayHi.bind(person, 21);
//Lydia is 21   function
//call方法会立即执行！
//.bind方法会返回函数的拷贝值，但带有绑定的上下文！ 它不会立即执行
```
13. 
```js
0;
new Number(0);
("");
(" ");
new Boolean(false);
undefined;
//假值 0,'',undefined

//JavaScript中只有6个假值：
undefined
null
NaN
0
'' (empty string)
false
```
14. 
```js
const numbers = [1, 2, 3];
numbers[10] = 11;
console.log(numbers);
//[1, 2, 3, 7 x empty, 11]
//你为数组中的元素设置一个超过数组长度的值时，JavaScript会创建一个名为“空插槽”的东西。 
//这些位置的值实际上是undefined
```
15. 
```js
(() => {
  let x, y;
  try {
    throw new Error();
  } catch (x) {
    (x = 1), (y = 2);
    console.log(x);
  }
  console.log(x);
  console.log(y);
})();
//1 undefined 2
//catch块接收参数x。当我们传递参数时，这与变量的x不同。这个变量x是属于catch作用域的。
//在catch块之外，x仍然是undefined，而y是2
```
16. 
```js
!!null;
!!"";
!!1;
// false false true
```
